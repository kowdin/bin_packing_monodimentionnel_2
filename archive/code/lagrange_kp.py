from instance import Instance
from heuristique import best_fit
from knapsack import Knapsack_solver

def relax_lagrange_kp(inst):

    # sous-problèmes de sac à dos
    kp_solver = Knapsack_solver(inst)

    # best fit
    nbBoite = best_fit(inst)
    print("best fit: ", nbBoite)

    # multiplicateurs
    mult = [0] * inst.nb_obj_tot
    # gradient de la fonction à maximiser
    grad = [0.] * inst.nb_obj_tot

    # solution du pb de sac à dos
    sol_kp = None

    continuer = True

    # paramètres pour les sous-gradients
    epsilon = 1.
    pas = 0.5
    rho = 0.6

    mult = [0.6988048057979975, 0.6973607880293397, 0.6979956482230926, 0.6939488831416757, 0.6938985450301736, 0.6620565949074577, 0.6508016314835707, 0.653045071204747, 0.6490937841738519, 0.6401779927394103, 0.6397685879837821, 0.6318792661739586, 0.6118074933020916, 0.6075117805283334, 0.59571063402322, 0.6001753255085733, 0.5922657390296295, 0.5896187338083928, 0.5929508662389157, 0.5915384912729882, 0.5927238105772775, 0.5855373701160237, 0.5826715179122122, 0.5776277789489282, 0.5779996484842496, 0.5716042000063627, 0.5611884357192383, 0.5626177750121256, 0.5645907760513234, 0.5559474532871304, 0.5567055915701259, 0.5498439236511286, 0.5509401548507953, 0.5473247110599139, 0.5475833219481525, 0.5337403685485691, 0.5214440239430832, 0.5183975936142614, 0.512674875144219, 0.5143189864628223, 0.5149933616358556, 0.5117050743502262, 0.50659386618499, 0.5007627638913987, 0.4920876730342338, 0.49313234537919337, 0.4933909996281788, 0.48618905945281704, 0.4836012484566957, 0.4826898808202046, 0.4707157990889051, 0.46119542867685287, 0.44653752223237403, 0.4352188080214455, 0.436798692275494, 0.42160822729030323, 0.4197178961172033, 0.4133349859147761, 0.40583137650120793, 0.4090358941251333, 0.4063439416872436, 0.39601461378194114, 0.40174370181908964, 0.4019742261666498, 0.4003846569186967, 0.3879238894311528, 0.3875195696296108, 0.38302411245165746, 0.3507627975441912, 0.34114909946434047, 0.34446087264013353, 0.34148750719050147, 0.3309589704878082, 0.32441140047418404, 0.3224828838616463, 0.31652225068425177, 0.3142128304911005, 0.31019752270536183, 0.3075935024553546, 0.3026367327663498, 0.30282091323778654, 0.3027330680049766, 0.30308358856990136, 0.29620802209141417, 0.29531011285785835, 0.29531586987334507, 0.2941746872312088, 0.29565131037661524, 0.2876804288330058, 0.28860591954914827, 0.2886098632110724, 0.27472064433649324, 0.27384901868790273, 0.2669222190002396, 0.2674478978743182, 0.2676493477637991, 0.26078660743496884, 0.2526139070121757, 0.25068910085239676, 0.2518754714309402, 0.24554137982115679, 0.2320563227082541, 0.2317939992099171, 0.23149983855328993, 0.22496299788120203, 0.22403278429523965, 0.20813866121075378, 0.20814443246015576, 0.20624707256694996, 0.19550002463602487, 0.1878807500064636, 0.1816727356133472, 0.18119114419384752, 0.1733490247999486, 0.1656337656316214, 0.1678820705364259, 0.15387840025910274, 0.14369802934819634, 0.14433973575335718, 0.1162564376264289]

    # opt cplex: 1.05813

    while continuer:

        # somme des multiplicateurs
        somme_mult = 0
        for elt in mult:
            somme_mult += elt

        # résolution du problème de sac à dos
        (kp_res, sol_kp) = kp_solver.resoudre(mult)

        print("res knapsack: ", kp_res)

        # print("util: ")
        # chaine = str()
        # for i in range(0, kp_solver.nb_obj):
        #     chaine += str(kp_solver.valeurs[i]/kp_solver.poids[i]) + ", "
        # print(chaine)

        relax = 0

        # si le résultat est > 1, alors le bin doit être utilisé
        if kp_res > 1:

            relax = (1-kp_res)*nbBoite + somme_mult
            # calcul du gradient
            for i in range(0,len(sol_kp)):
                grad[i] = 1. - nbBoite*sol_kp[i]
            # calcul du pas
            somme_x = 0
            for x in sol_kp:
                somme_x += x
            somme_x -= 1
            # pas = epsilon * ( (nbBoite-relax) / (somme_x*somme_x) )

        else:
            relax = somme_mult
            # calcul du gradient
            grad = [1.]*inst.nb_obj_tot
            # pas = epsilon * (nbBoite-relax)

        print("relaxation lagrangienne: ", relax)
        print("pas: ", pas)

        pas = pas*rho
        rho = rho*0.5

        # mise à jour des multiplicateurs
        for i in range(0, len(mult)):
            mult[i] += pas*grad[i]

        if(pas <= 10**-18):
            continuer = False

        continuer = False
